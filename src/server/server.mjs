import express, { json, response } from "express";
import morgan from 'morgan';
import dayjs from "dayjs";

/* import models */
import {Bag, User, Establishment, Reservation, Cart, BagItem, CartItem} from "../models/index.mjs";

import {createBagsRouter} from "./routes/bags.js";
import {createUsersRouter} from "./routes/users.js";
import {createCartsRouter} from "./routes/carts.js";
import {createEstablishmentsRouter} from "./routes/establishments.js";
import {createReservationsRouter} from "./routes/reservations.js";


const PORT = 3001; //server port


// TESTING
/* SAMPLE DATA FOR TESTING */

//global sample data
//global available bags
//global sample id for bags: 1, 2, 3, 4
const availableBags = [

    new Bag(1, Bag.TYPE_REGULAR, 101, "large", "vegan",
        5, "2025-03-30 10:00:00", "2025-04-31 12:00:00"),
    new Bag(2, Bag.TYPE_REGULAR, 102, "large", "vegan",
        10, "2025-03-13 14:00:00", "2025-07-14 16:00:00"),
    new Bag(3, Bag.TYPE_REGULAR, 103, "large", "vegan",
        15, "2025-03-20 14:00:00", "2025-09-21 16:00:00"),
    new Bag(4, Bag.TYPE_REGULAR, 104, "large", "vegan",
        20, "2025-03-25 14:00:00", "2025-03-24 16:00:00"),
];


/* BAG REPO - TESTING */

const BagRepoTesting = {


    /** 
     * Creates a new empty bag.
     * @param {Bag} bagType - Type of the bag (e.g., "regular", "surprise").
     * @param {number} estId - The establishment ID associated with the bag.
     * @param {number} size - "small", "medium", "large".
     * @param {Array<string>} tags - Example: ["vegan", "gluten free"].
     * @param {number} price - The price of the bag.
     * @param {string} pickupTimeStart - The start time for pickup in ISO 8601 format.
     * @param {string} pickupTimeEnd - The end time for pickup in ISO 8601 format.
     * @returns {Bag} - The bag that was added to the cart, with the new ID generated by the system.
     */
    async createBag(bagType, estId, size, tags, price, pickupTimeStart, pickupTimeEnd) {
        //put a newly created bag in the availableBags array
        const newBag = new Bag(availableBags.length + 1, bagType, estId, size, tags, price, pickupTimeStart, pickupTimeEnd);
        availableBags.push(newBag);

        return newBag;
    },

    /**
     * Returns the bag with the given ID.
     * @param {number} bagId
     * @returns {Bag}
     */
    async getBag(bagId) { 
        //return the bag with the given id, if it exists
        //otherwise, return null
        if (bagId <= availableBags.length){
            return availableBags.find(b => b.id === bagId);
        }

        return null;
    },

    /** 
    * Get all the bags of an establishment by estId
    * @param {number} estId
    * @returns {Array<Bag>} - The bags of the establishment - or null if no bags are found
    */
    async getBagsByEstId(estId) {
        //get all the bags of the establishment by estId

        let response = [];
        for (let i = 0; i < availableBags.length; i++){
            if (availableBags[i].estId === estId){
                response.push(availableBags[i]);
            }
        }

        if (response.length === 0){
            return null;
        }

        return response;
    },


    /**
     * Lists all the available bags, from every establishment.
     * A bag is available if no one reserved it yet and it can be picked up now.
     * 
     * @returns {Array<Bag>}
     */
    async listAvailable() {
        //scan all the bags and check wether they're available right now 
        let res_ = [];
        for (let i = 0; i < availableBags.length; i++){
            if (availableBags[i].reservedBy === null){
                
                //now check if pickupTimeStart is before now and pickupTimeEnd is after now
                const now = dayjs().toDate(); //in millis

                const bagPickUpStart = availableBags[i].pickupTimeStart.toDate(); //in millis
                const bagPickUpEnd = availableBags[i].pickupTimeEnd.toDate(); //in millis


                if (bagPickUpStart <= now && bagPickUpEnd >= now){
                    res_.push(availableBags[i]);
                }
            }
        }

        if (res_.length === 0){
            //return null
            return null;
        }

        return res_;
    }


}









const UserRepoTesting = {

    users: [],
    uid: 1,

    //populate with example user
    constructor() {
        this.users.push(new User(1, "mail@esempio.com", "Forza", "Toro")); //example user just for testing
        this.uid++;
    },

    async getUserById(id) {
        //return the user with the given id, if it exists
        //if not, return null
        for (let i=0; i<this.users.length; i++){
            if (this.users[i].id === id){
                return this.users[i];
            }
        }

        return null;
    },

    //function to create a new user
    /**
     * @param {string} email
     * @param {string} assignedName
     * @param {string} familyName
     * @returns {User}
     */
    async createUser(email, assignedName, familyName) { 
        const newUser = new User(this.uid++, email, assignedName, familyName);
        this.users.push(newUser);
        console.log("New user created: ", newUser);
        return newUser;
    },

    /**
     * @param {number} id
     * @returns {User}
     */
    async updateUser(id, email, assignedName, familyName) { 
        //update user into the users array
        for (let i=0; i<this.users.length; i++){
            if (this.users[i].id === id){
                this.users[i].email = email;
                this.users[i].assignedName = assignedName;
                this.users[i].familyName = familyName;

                return `Updated user with id ${id}: ${email}, ${assignedName}, ${familyName}`;
            }
        }

        return null;
    },

    //delete user by userid
    async deleteUser(id) {
        //delete user from the users array
        for (let i=0; i<this.users.length; i++){
            if (this.users[i].id === id){
                this.users.splice(i, 1);
                return `Deleted user with id ${id}`;
            }
        }

        //throw an error if the user is not found
        throw new Error(`Error: user with id ${id} not found!`);
    },


    /**
     * @param {number} id
     * @param {string} email
     * @param {string} assignedName
     * @param {string} familyName
     */
    async updateUser(id, email, assignedName, familyName) { 
        //update user into the users array
        for (let i=0; i<this.users.length; i++){
            if (this.users[i].id === id){
                this.users[i].email = email;
                this.users[i].assignedName = assignedName;
                this.users[i].familyName = familyName;

                return `Updated user with id ${id}: ${email}, ${assignedName}, ${familyName}`;
            }
        }

        return null;
    }
}


const CartRepoTesting = {

    //add bag id
    currentBagId: 1,

    //dictionary of carts, the key is the user id, the value is the cart
    carts: {},


    async getCart_sample(userId) {
        //return a new object Cart with the user's cart
        let sampleCart = new Cart(userId);
        //add the 2 bags
        const bag1 = new Bag(
            this.currentBagId++, Bag.TYPE_REGULAR, 101, "large", "vegan",
            5, "2025-03-30 10:00:00", "2025-03-31 12:00:00"
        );

        const bag2 = new Bag(
            this.currentBagId++, Bag.TYPE_REGULAR, 102, "large", "vegan",
            10, "2025-03-13 14:00:00", "2025-03-14 16:00:00"
        );

        //add item to bag[0]
        //constructor(bagId, id, name, quantity)
        bag1.addItem(new BagItem(1, 1, "peanuts", 2));
        bag1.addItem(new BagItem(1, 2, "chocolate", 1));

        //add item to bag[1]
        //constructor(bagId, id, name, quantity)
        bag2.addItem(new BagItem(2, 1, "peanuts", 2));
        bag2.addItem(new BagItem(2, 2, "chocolate", 1));


        //console.log("bags0, date: ", bags[0]);
        sampleCart.addItem(new CartItem(bag1));
        sampleCart.addItem(new CartItem(bag2));

        return sampleCart;
    },

    //get the cart of the user
    async getCart(userId) {
        //check if the user has a cart
        if (!this.carts[userId]) {
            return null;
        } else {

            //if the user has a cart but has deleted all the bags from it, return null
            if (this.carts[userId].items.length === 0){
                return null;
            }
            
            return this.carts[userId];
        }
    },


    //add bag, so a cartItem,  to the user's cart
    async addBag(userId, bagId) {
        //check if the user already has a cart
        //if not, create a new cart
        //if yes, add the cartItem to the already existing cart
        if (!this.carts[userId]) {
            this.carts[userId] = new Cart(userId);
        } else {
            //check if the bag is already in the cart
            //cartItem -> bag -> retrieve bagId
            if (this.carts[userId].items.find(item => item.bag.id === bagId)) {
                //throw an error if the bag is already in the cart
                throw new Error(`Bag ${bagId} already in the cart!`);
            } 
        }


        //add the bag, so the cartItem, to the cart
        const bag = availableBags.find(b => b.id === bagId);
        if (!bag) {
            return null;
        }
        //add the corresponding cartItem, which can be further customized by the end user, to the cart
        //Reminder: a cartItem is essentially a bag with a list of removed items, that can be choosen by the end user
        this.carts[userId].addItem(new CartItem(bag));
        return `Bag ${bagId} succesfully added to the cart!`;
        
    },

    //remove bag, so a cartItem, from the user's cart
    async removeBag(userId, bagId) {
        //check if the user has a cart
        if (!this.carts[userId]) {
            throw new Error(`Cart for user ${userId} not found!`);
        } else {
            //check if the bag, so the cartItem, is in the cart
            //cartItem -> bag -> retrieve bagId
            const index = this.carts[userId].items.findIndex(item => item.bag.id === bagId);
            if (index === -1) {
                throw new Error(`Bag ${bagId} not found in the cart!`);
            } else {
                //remove the bag from the cart
                this.carts[userId].items.splice(index, 1);
                return `Bag ${bagId} succesfully removed from the cart!`;
            }
        }

    },



}


const ReservationRepoTesting = {

        resId: 1,
        reservations: [],

        async createReservations(userId, cartItems) {
            let c = 0;
            for (const cartItem of cartItems) {
                const reservation = new Reservation(this.resId++, userId, cartItem);
                this.reservations.push(reservation);
                ++c;                      
            }

            return `Created ${c} reservations!`;
        },

        async createReservationSingle(userId, cartItem) {
            const reservation = new Reservation(this.resId++, userId, cartItem);
            this.reservations.push(reservation);

            return reservation;

        },

        async cancelReservation(resId) {
            const reservationId = parseInt(resId);
            const index = this.reservations.findIndex(r => r.id === reservationId);

            if (index === -1) {
                throw new Error(`Error: Reservation ${reservationId} not found!`);
            }

            //this.reservations[index].cancel();
            this.reservations.splice(index, 1);
            
            //res.json({ message: `Reservation ${reservationId} succesfully deleted!` });
            return `Reservation ${resId} succesfully deleted!` ;

        },

        async getReservations() {
            //return all the reservations in json format
            return this.reservations;

        }

}



const EstablishmentRepoTesting = {


    estId: 1,
    estBags: {},
    est: {},

    //create a new establishment
    async createEstablishment(name, estType) {

        const newEst = new Establishment(this.estId++, name, [], estType);
        this.estBags[newEst.id] = [];
        this.est[newEst.id] = newEst;
        return newEst;
    },



    //get establishment bags by id
    async getEstablishmentBags(estId) {
        //if the establishment exists, return it
        //otherwise, return error
        const response = this.estBags[estId];
        if (response) {
            return response;
        }

        return null;
    },


    //get establishment by id
    async getEstablishment(estId) {
        //if the establishment exists, return it
        //otherwise, return error
        const response = this.est[estId];
        if (response) {
            return response;
        }

        return null;
    },




    //list all the saved establishments
    async listAllEstablishments(){
        return this.estBags;
    },


    //delete an establishment by estId
    async deleteEstablishment(estId) {
        //delete the establishment and also all the issued bags
        //if the establishment exists, delete it
        //otherwise, return error

        if (this.est[estId]){
            delete this.est[estId];
            delete this.estBags[estId];
            return `Establishment ${estId} succesfully deleted!`;
        } else {
            return `Establishment ${estId} not found!`;
        }

    }


}
// END TESTING



// repos: { bagRepo, userRepo, cartRepo, resRepo, estRepo }    
function startServer(repos) {
    const server = express();

    /* MIDDLEWARES */
    // morgan used for logging about requests on the terminal
    server.use(morgan("dev"));
    // register json middleware to send data in json format
    server.use(express.json());


    /* home - GET*/
    server.get('/', (req, res) => {
        // the callback is the handler to the method
        res.send("Hello World!") // send content to the client
        // send method sets the body of the response
    })

    server.use("/bags", createBagsRouter(repos));
    server.use("/users", createUsersRouter(repos));
    server.use("/carts", createCartsRouter(repos));
    server.use("/reservations", createReservationsRouter(repos));
    server.use("/establishments", createEstablishmentsRouter(repos));


    server.listen(PORT, () => {console.log(`Server started on http://localhost:${PORT}`);})
}

startServer({
    bagRepo: BagRepoTesting,
    userRepo: UserRepoTesting,
    cartRepo: CartRepoTesting,
    resRepo: ReservationRepoTesting,
    estRepo: EstablishmentRepoTesting
});


