import sqlite3 from 'sqlite3';
import dayjs from 'dayjs';
import {pathDbFromRepos, connect} from '../../database/index.js';
import Reservation, { CartItem } from '../models/index.mjs'
import { UserRepo } from './UserRepo.mjs';
import { BagRepo, CartItemRepo } from './index.mjs';

export class ReservationRepo {
    constructor(db) {
        this.DB = db;
    }

    /**
     * Creates a new reservation for each cart item.
     * If any of the cart items cannot be reserved, no reservations should be created.
     * @param {Reservation} reservation
     * @returns {Reservation} - The reservations that were created, with the new IDs generated by the system.
     */
    async createReservation(reservation) {
        let query = 'INSERT INTO RESERVATION (cartItemId, createdAt, canceledAt) VALUES (?, ?, ?, ?)';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [reservation.cartItem.id, reservation.createdAt, reservation.canceledAt], async function (err) {
                if (err) {
                    console.err("Error creating reservation: ", err.message);
                    reject(err);
                } else {
                    console.log("Reservation inserted succesfully");
                    await this.setAvailableAttributesForBags(reservation.cartItem.id, 0);
                    resolve(reservation);
                }
            })
        })
    }

    /**
     * 
     * @param {CartItem} cartItem
     * @returns {Reservation} 
     */

    async getReservationByCartItemId(cartItemId) {
        let query = 'SELECT * FROM RESERVATION WHERE cartItemId = ?';
        return new Promise((resolve, reject) => {
            this.DB.all(query, [cartItemId], async (err, row) => {
                if (err) {
                    console.error('Error retriving reservation: ', err.message);
                    reject(null);
                } else {
                    if (row) {
                        let cartItemId = parseInt(row[0].cartItemId, 10);
                        let createdAt = dayjs(row[0].createdAt, 'YYYY-MM-DD');
                        let canceledAt = dayjs(row[0].canceledAt, 'YYYY-MM-DD');

                        let cartItemRepo = new CartItemRepo(this.DB);
                        let userRepo = new UserRepo(this.DB);
                        let cartItem = await cartItemRepo.getCartItemById(cartItemId);
                        let userId = await cartItemRepo.getUserIdByCartItemId(cartItemId);
                        let user = await userRepo.getUserById(userId); 
                        let fetchedReservation = new Reservation(cartItem, user, createdAt, canceledAt);

                        resolve(fetchedReservation);
                    } else {
                        resolve(null);
                    }
                }
            })
        })
    }

    /**
     * 
     * @param {number} cartItemId ;
     * @returns
     */

    async setAvailableAttributesForBags(cartItemId, available) {
        let cartItemRepo = new CartItemRepo(this.DB);
        let bagRepo = new BagRepo(this.DB);
        bagId_list = await cartItemRepo.getBagIdListFromCartItemId(cartItemId);

        bagId_list.forEach(async bagId => {
            bagId = parseInt(bagId, 10);
            await bagRepo.setAvailable(bagId, available);
        })

        return;
    }


    async getReservationByDate(userId, estId, createdAt) {
        
    }

    /**
     * Returns ALL the reservations made by a user, even the cancelled ones.
     * @param {number} userId
     * @returns {Array<Reservation>}
     */
    async listReservationsByUser(userId) {
        let cartItemRepo = new CartItemRepo(this.DB);
        let cartItem_list = await cartItemRepo.getCartItemListByUserId(userId);

        reservation_list = []
        cartItem_list.forEach(async cartItem => {
            let reservation = await this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        })
        return(reservation_list);
    }

    /**
     * Returns ALL the reservations made for an establishment, even the cancelled ones.
     * @param {number} estId
     * @returns {Array<Reservation>}
     */
    async listReservationsByEstablishment(estId) {
        let cartItemRepo = new CartItemRepo(this.DB);
        let cartItem_list = await cartItemRepo.getCartItemListByEstId(estId);

        reservation_list = []
        cartItem_list.forEach(async cartItem => {
            let reservation = await this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        })
        return(reservation_list);
    }

    /**
     * Cancel a reservation, without deleting it.
     * @param {Reservation} reservation
     */
    async cancelReservation(reservation) {
        let query = 'UPDATE RESERVATION SET canceledAt = ? WHERE cartItemId = ?';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [reservation.canceledAt, reservation.cartItem.id], async (err) => {
                if (err) {
                    console.err('Error updating canceledAt in Reservation: ', err.message);
                    reject(err);
                } else {
                    console.log('Reservation canceled succesfully');
                    await this.setAvailableAttributesForBags(reservation.cartItem.id, 1);
                    resolve(null);
                }
            })
        })
    }
}
