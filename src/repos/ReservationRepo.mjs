import sqlite3 from 'sqlite3';
import {pathDbFromRepos, connect} from '../../database/index.js';
import Reservation from '../models/index.mjs'

export class ReservationRepo {

    constructor() {
        this.pathDB = pathDbFromRepos;
        this.DB = connect(this.pathDB);
    }

    /**
     * Creates a new reservation for each cart item.
     * If any of the cart items cannot be reserved, no reservations should be created.
     * @param {Reservation} reservation
     * @returns {Reservation} - The reservations that were created, with the new IDs generated by the system.
     */
    async createReservation(reservation) {
        let query = 'INSERT INTO RESERVATION (userId, createdAt, canceledAt, totPrice) VALUES (?, ?, ?, ?)';
        return new Promise ((resolve, reject) => {
            this.DB.all(query, [reservation.userId, reservation.createdAt, reservation.canceledAt, reservation.totPrice], (err) => {
                if (err) {
                    console.error('Error inserting reservation: ', err.message);
                    reject(err);
                } else {
                    console.log('Reservation inserted successfully with ID:', this.lastID);
                    let fetchedReservation = this.getReservationById(this.lasID);
                    resolve(fetchedReservation);
                }
            })
        })
    }

    /**
     * 
     * @param {Reservation} reservation
     * @returns 
     */

    async updateReservation(reservation) {
        let query = 'UPDATE RESERVATION SET userId = ?, createdAt = ?, canceledAt = ?, totPrice = ? WHERE id = ?';
        return new Promise ((resolve, reject) => {
            this.DB.run(query, [reservation.userId, reservation.createdAt, reservation.canceledAt, reservation.totPrice, reservation.id], (err) => {
                if (err) {
                    console.error('Error updating reservation: ', err.message);
                    reject(err);
                } else {
                    console.log('Reservation updated successfully');
                    resolve(null);
                }
            })
        })
    }

    /**
     * 
     * @param {*} id
     * @returns {Reservation} 
     */

    async getReservationById(id) {
        let query = 'SELECT * FROM RESERVATION WHERE id = ?';
        return new Promise((resolve, reject) => {
            this.DB.all(query, [id], (err, row) => {
                if (err) {
                    console.error('Error retriving reservation: ', err.message);
                    reject(err);
                } else {
                    if (row) {
                        let id = parseInt(row[0].id, 10);
                        let userId = parseInt(row[0].userId, 10);
                        let createdAt = row[0].createdAt;
                        let canceledAt = row[0].canceledAt;
                        let totPrice = parseFloat(row[0].totPrice);

                        let fetchedReservation = new Reservation(id, userId, createdAt, canceledAt, totPrice);
                        resolve(fetchedReservation);
                    } else {
                        resolve(null);
                    }
                }
            })
        })
    }

    /**
     * Returns ALL the reservations made by a user, even the cancelled ones.
     * @param {number} userId
     * @returns {Array<Reservation>}
     */
    async listReservationsByUser(userId) {
    }

    /**
     * Returns ALL the reservations made for an establishment, even the cancelled ones.
     * @param {number} estId
     * @returns {Array<Reservation>}
     */
    async listReservationsByEstablishment(estId) {}

    /**
     * Cancel a reservation, without deleting it.
     * @param {number} resId - The ID of the reservation to be cancelled.
     */
    async cancelReservation(resId) {}
}
