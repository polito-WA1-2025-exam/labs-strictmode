import sqlite3 from 'sqlite3';
import {pathDbFromRepos, connect} from '../../database/index.js';
import Reservation, { CartItem } from '../models/index.mjs'
import { UserRepo } from './UserRepo.mjs';
import { CartItemRepo } from './index.mjs';

export class ReservationRepo {

    constructor() {
        this.pathDB = pathDbFromRepos;
        this.DB = connect(this.pathDB);
    }

    /**
     * Creates a new reservation for each cart item.
     * If any of the cart items cannot be reserved, no reservations should be created.
     * @param {Reservation} reservation
     * @returns {Reservation} - The reservations that were created, with the new IDs generated by the system.
     */
    async createReservation(reservation) {
        let query = 'INSERT INTO RESERVATION (cartItemId, createdAt, canceledAt) VALUES (?, ?, ?, ?)';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [reservation.cartItem.id, reservation.createdAt, reservation.canceledAt], (err) => {
                if (err) {
                    console.err("Error creating reservation: ", err.message);
                    reject(err);
                } else {
                    console.log("Reservation inserted succesfully");
                    resolve(reservation);
                }
            })
        })
    }

    /**
     * 
     * @param {CartItem} cartItem
     * @returns {Reservation} 
     */

    async getReservationByCartItemId(cartItemId) {
        let query = 'SELECT * FROM RESERVATION WHERE cartItemId = ?';
        return new Promise((resolve, reject) => {
            this.DB.all(query, [cartItemId], (err, row) => {
                if (err) {
                    console.error('Error retriving reservation: ', err.message);
                    reject(null);
                } else {
                    if (row) {
                        let cartItemId = parseInt(row[0].cartItemId, 10);
                        let createdAt = row[0].createdAt;
                        let canceledAt = row[0].canceledAt;

                        let cartItemRepo = new CartItemRepo();
                        let userRepo = new UserRepo();
                        let cartItem = cartItemRepo.getCartItemById(cartItemId);
                        let userId = cartItemRepo.getUserIdByCartItemId(cartItemId);
                        let user = userRepo.getUserById(userId); 
                        let fetchedReservation = new Reservation(cartItem, user, createdAt, canceledAt);

                        resolve(fetchedReservation);
                    } else {
                        resolve(null);
                    }
                }
            })
        })
    }

    async getReservationByDate(userId, estId, createdAt) {
        
    }

    /**
     * Returns ALL the reservations made by a user, even the cancelled ones.
     * @param {number} userId
     * @returns {Array<Reservation>}
     */
    async listReservationsByUser(userId) {
        let cartItemRepo = new CartItemRepo();
        let cartItem_list = cartItemRepo.getCartItemListByUserId(userId);

        reservation_list = []
        cartItem_list.forEach(cartItem => {
            let reservation = this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        })
        return(reservation_list);
    }

    /**
     * Returns ALL the reservations made for an establishment, even the cancelled ones.
     * @param {number} estId
     * @returns {Array<Reservation>}
     */
    async listReservationsByEstablishment(estId) {
        let cartItemRepo = new CartItemRepo();
        let cartItem_list = cartItemRepo.getCartItemListByEstId(estId);

        reservation_list = []
        cartItem_list.forEach(cartItem => {
            let reservation = this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        })
        return(reservation_list);
    }

    /**
     * Cancel a reservation, without deleting it.
     * @param {Reservation} reservation
     */
    async cancelReservation(reservation) {
        let query = 'UPDATE RESERVATION SET canceledAt = ? WHERE cartItemId = ?';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [reservation.canceledAt, reservation.cartItem.id], (err) => {
                if (err) {
                    console.err('Error updating canceledAt in Reservation: ', err.message);
                    reject(err);
                } else {
                    console.log('Reservation canceled succesfully');
                    resolve(null);
                }
            })
        })
    }
}
