import dayjs from 'dayjs';
import {Reservation, CartItem } from '../models/index.mjs'
import { BagRepo, CartItemRepo } from './index.mjs';

export class ReservationRepo {
    constructor(db) {
        this.DB = db;
    }

    /**
     * Creates a new reservation for each cart item.
     * If any of the cart items cannot be reserved, no reservations should be created.
     * @param {Reservation} reservation
     * @returns {Reservation} - The reservations that were created, with the new IDs generated by the system.
     */
    async createReservation(reservation) {
        const bagRepo = new BagRepo(this.DB);


        await this.DB.run('BEGIN TRANSACTION'); //Start explicit transaction

        //check the bag is available at the time of reservation
        const isBagAvailable = await bagRepo.checkBagAvailable(reservation.cartItem.bag.id);
        if (!isBagAvailable) {
            throw new Error("Bag is not available anymore!");
        }

        try {
           //canceledAt is set to null by default (see create_db.mjs), so it is not included in the query when creating a new Reservation.
            const query = 'INSERT INTO RESERVATION (cartItemId, userId, createdAt) VALUES (?, ?, ?)';
            const promiseRes = await new Promise((resolve, reject) => {
                this.DB.run(query, [reservation.cartItem.id, reservation.userId, reservation.createdAt], function (err) {
                    if (err) {
                        console.error("Error creating reservation: ", err.message);
                        return reject(err);
                    }
                    console.log("Reservation inserted succesfully");
                    reservation.id = this.lastID;
                    resolve(reservation);
                });
            });
            
            //Set bag availability to false
            await bagRepo.setAvailable(reservation.cartItem.bag.id, false);

            await this.DB.run('COMMIT');
            return promiseRes;
        } catch (error) {
            console.error("Error during reservation creation: ", error.message);
            await this.DB.run('ROLLBACK'); //Rollback the WHOLE transaction in case of error
            throw error;
        }
    }

    /**
     * Function to enforce the contraint: each user can only rererve 1 bag for each establishment at a day
     * @param {*} userId 
     * @param {*} createdAt 
     * @param {*} estId 
     * @returns true if the user has a reservation for the same establishment at the same day, false otherwise.
     * TLDR: true if BAD, false if GOOD
     */
    async checkEstablishmentContraint(userId, createdAt, estId) {
        const query = `
            SELECT COUNT(*)
            FROM RESERVATION
            WHERE userId = ?
            AND createdAt = ?
            AND canceledAt IS NULL
            AND cartItemId IN (
                SELECT id
                FROM CART_ITEM
                WHERE bagId IN (
                SELECT id
                FROM BAG
                WHERE estId = ?
                )
            )`;
        return new Promise((resolve, reject) => {
            this.DB.get(query, [userId, createdAt, estId], (err, row) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(row && row['COUNT(*)'] > 0); //this will return true if the user has a reservation for the same establishment at the same day
                }
            });
        });
    }

    /**
     * 
     * @param {CartItem} cartItem
     * @returns {Reservation} 
     */

    async getReservationByCartItemId(cartItemId) {
        const query = 'SELECT * FROM RESERVATION WHERE cartItemId = ?';
        const db = this.DB;
        return new Promise((resolve, reject) => {
            this.DB.get(query, [cartItemId], async (err, row) => {
                if (err) {
                    console.error('Error retriving reservation: ', err.message);
                    reject(null);
                } else {
                    if (row) {
                        const id = parseInt(row.id);
                        const cartItemId = parseInt(row.cartItemId);
                        const userId = parseInt(row.userId);
                        const createdAt = dayjs(row.createdAt, 'YYYY-MM-DD');
                        let canceledAt = null;
                        if (row.canceledAt) {
                            canceledAt = dayjs(row.canceledAt, 'YYYY-MM-DD');
                        }


                        const cartItemRepo = new CartItemRepo(db);
                        const reservedCartItem = await cartItemRepo.getCartItemById(cartItemId);
                        //                                      id, userId, cartItem, createdAt
                        let fetchedReservation = new Reservation(id, userId, reservedCartItem, createdAt, canceledAt);

                        resolve(fetchedReservation);
                    } else {
                        resolve(null);
                    }
                }
            })
        })
    }

    /**
     * 
     * @param {number} cartItemId ;
     * @returns
     */

    async setAvailableAttributesForBags(cartItemId, available) {
        let cartItemRepo = new CartItemRepo(this.DB);
        let bagRepo = new BagRepo(this.DB);
        const bagId_list = await cartItemRepo.getBagIdListFromCartItemId(cartItemId);

        bagId_list.forEach(async bagId => {
            bagId = parseInt(bagId, 10);
            await bagRepo.setAvailable(bagId, available);
        })

        return;
    }


    


    /**
     * Returns ALL the reservations made by a user, even the cancelled ones.
     * @param {number} userId
     * @returns {Array<Reservation>}
     */
    async listReservationsByUser2(userId) {
        const cartItemRepo = new CartItemRepo(this.DB);
        const cartItem_list = await cartItemRepo.getCartItemListByUserId(userId);

        const reservation_list = [];
        for (const cartItem of cartItem_list) {
            const reservation = await this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        }

        return(reservation_list);
    }


    /**
     * Returna the reservations made by a user, filtered by the fetchingMode.
     * * @param {number} userId
     * * @param {string} fetchingMode - 'active', 'canceled' or 'all' (default).
     * * @returns {Array<Reservation>} - The reservations made by the user, filtered by the fetchingMode.
     */
    async listReservationsByUser(userId, fetchingMode = 'all') {
        let query = "SELECT * FROM RESERVATION where userId = ?";
        if (fetchingMode === 'active') {
            query += " AND canceledAt IS NULL";
        } else if (fetchingMode === 'canceled') {
            query += " AND canceledAt IS NOT NULL";
        } 
        //otherwise, it will fetch all the reservations (active and canceled -> fetchingMode = 'all')

        const db = this.DB;

        return new Promise((resolve, reject) => {
            this.DB.all(query, [userId], async (err, rows) => {
                if (err) {
                    console.error('Error retrieving reservations: ', err.message);
                    reject(err);
                } else {
                    
                    if (rows && rows.length > 0) {
                        const cartItemRepo = new CartItemRepo(db);
                        const reservation_list = [];

                        for (const row of rows) {
                            const id = parseInt(row.id);
                            const cartItemId = parseInt(row.cartItemId);
                            const userId = parseInt(row.userId);
                            const createdAt = dayjs(row.createdAt, 'YYYY-MM-DD');
                            let canceledAt = null;
                            if (row.canceledAt) {
                                canceledAt = dayjs(row.canceledAt, 'YYYY-MM-DD');
                            }

                            const reservedCartItem = await cartItemRepo.getCartItemById(cartItemId);
                            
                            let fetchedReservation = new Reservation(id, userId, reservedCartItem, createdAt, canceledAt);
                            
                            reservation_list.push(fetchedReservation);
                        }

                        resolve(reservation_list);
                    }
                }
            })

        });




    }

    /**
     * Returns ALL the reservations made for an establishment, even the cancelled ones.
     * @param {number} estId
     * @returns {Array<Reservation>}
     */
    async listReservationsByEstablishment(estId) {
        const cartItemRepo = new CartItemRepo(this.DB);
        const cartItem_list = await cartItemRepo.listCartItemsByEstablishmentId(estId);

        const reservation_list = []
        for (const cartItem of cartItem_list) {
            const reservation = await this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        }
        return(reservation_list);
    }

    /**
     * Cancel a reservation, without deleting it.
     * @param {Reservation} reservation
     */
    async cancelReservation(reservation) {
        const bagRepo = new BagRepo(this.DB);
        try {
            await this.DB.run('BEGIN TRANSACTION'); //Start explicit transaction
    
            //Attempt to set bag availability first
            await bagRepo.setAvailable(reservation.cartItem.bag.id, true);
    
            //If successful, then finalize the reservation cancellation
            const query = 'UPDATE RESERVATION SET canceledAt = ? WHERE id = ?'; 
            await new Promise((resolve, reject) => {
                this.DB.run(query, [reservation.canceledAt, reservation.id], (err) => { 
                    if (err) {
                        console.error('Error updating canceledAt in Reservation: ', err.message);
                        return reject(err);
                    } else {
                        resolve(null);
                    }
                });
            });
    
            //Commit the transaction if everything went well
            await this.DB.run('COMMIT');
            return null;
        } catch (error) {
            // Rollback the transaction in case of error
            await this.DB.run('ROLLBACK');
            console.error("Error during cancellation process: ", error.message);
            throw error;
        }
    }
}
