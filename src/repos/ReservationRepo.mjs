import sqlite3 from 'sqlite3';
import dayjs from 'dayjs';
import {pathDbFromRepos, connect} from '../../database/index.js';
import {Reservation, CartItem } from '../models/index.mjs'
import { UserRepo } from './UserRepo.mjs';
import { BagRepo, CartItemRepo } from './index.mjs';

export class ReservationRepo {
    constructor(db) {
        this.DB = db;
    }

    /**
     * Creates a new reservation for each cart item.
     * If any of the cart items cannot be reserved, no reservations should be created.
     * @param {Reservation} reservation
     * @returns {Reservation} - The reservations that were created, with the new IDs generated by the system.
     */
    async createReservation(reservation) {
        const self = this; 
        //canceledAt is set to null by default (see create_db.mjs), so it is not included in the query when creating a new Reservation.
        const query = 'INSERT INTO RESERVATION (cartItemId, userId, createdAt) VALUES (?, ?, ?)';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [reservation.cartItem.id, reservation.userId, reservation.createdAt], async function (err) {
                if (err) {
                    console.err("Error creating reservation: ", err.message);
                    reject(err);
                } else {
                    console.log("Reservation inserted succesfully");

                    try {
                        const bagRepo = new BagRepo(self.DB);
                        //set bag availability to false
                        await bagRepo.setAvailable(reservation.cartItem.bag.id, false);

                        //retrieve lastId of the reservation created
                        reservation.id = this.lastID;
                        resolve(reservation);
                    } catch (error) {
                        console.error("Error setting bag availability: ", error.message);
                        reject(error);
                    }
                }
            })
        })
    }

    /**
     * Function to enforce the contraint: each user can only rererve 1 bag for each establishment at a day
     * @param {*} userId 
     * @param {*} createdAt 
     * @param {*} estId 
     * @returns 
     */
    async checkEstablishmentContraint(userId, createdAt, estId) {
        const query = 'SELECT COUNT(*) FROM RESERVATION WHERE userId = ? AND createdAt = ? AND canceledAt IS NULL AND cartItemId IN (SELECT id FROM CART_ITEM WHERE estId = ?)';
        return new Promise((resolve, reject) => {
            this.DB.get(query, [userId, createdAt, estId], (err, row) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(row && row['COUNT(*)'] > 0); //this will return true if the user has a reservation for the same establishment at the same day
                }
            });
        });
    }

    /**
     * 
     * @param {CartItem} cartItem
     * @returns {Reservation} 
     */

    async getReservationByCartItemId(cartItemId) {
        const query = 'SELECT * FROM RESERVATION WHERE cartItemId = ?';
        const db = this.DB;
        return new Promise((resolve, reject) => {
            this.DB.get(query, [cartItemId], async (err, row) => {
                if (err) {
                    console.error('Error retriving reservation: ', err.message);
                    reject(null);
                } else {
                    if (row) {
                        const id = parseInt(row.id);
                        const cartItemId = parseInt(row.cartItemId);
                        const userId = parseInt(row.userId);
                        const createdAt = dayjs(row.createdAt, 'YYYY-MM-DD');
                        let canceledAt = null;
                        if (row.canceledAt) {
                            canceledAt = dayjs(row.canceledAt, 'YYYY-MM-DD');
                        }

                        const cartItemRepo = new CartItemRepo(db);
                        const reservedCartItem = await cartItemRepo.getCartItemById(cartItemId);
                        //                                      id, userId, cartItem, createdAt
                        let fetchedReservation = new Reservation(id, userId, reservedCartItem, createdAt, canceledAt);

                        resolve(fetchedReservation);
                    } else {
                        resolve(null);
                    }
                }
            })
        })
    }

    /**
     * 
     * @param {number} cartItemId ;
     * @returns
     */

    async setAvailableAttributesForBags(cartItemId, available) {
        let cartItemRepo = new CartItemRepo(this.DB);
        let bagRepo = new BagRepo(this.DB);
        const bagId_list = await cartItemRepo.getBagIdListFromCartItemId(cartItemId);

        bagId_list.forEach(async bagId => {
            bagId = parseInt(bagId, 10);
            await bagRepo.setAvailable(bagId, available);
        })

        return;
    }


    


    /**
     * Returns ALL the reservations made by a user, even the cancelled ones.
     * @param {number} userId
     * @returns {Array<Reservation>}
     */
    async listReservationsByUser(userId) {
        const cartItemRepo = new CartItemRepo(this.DB);
        const cartItem_list = await cartItemRepo.getCartItemListByUserId(userId);

        const reservation_list = [];
        for (const cartItem of cartItem_list) {
            const reservation = await this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        }

        return(reservation_list);
    }

    /**
     * Returns ALL the reservations made for an establishment, even the cancelled ones.
     * @param {number} estId
     * @returns {Array<Reservation>}
     */
    async listReservationsByEstablishment(estId) {
        const cartItemRepo = new CartItemRepo(this.DB);
        const cartItem_list = await cartItemRepo.listCartItemsByEstablishmentId(estId);

        const reservation_list = []
        for (const cartItem of cartItem_list) {
            const reservation = await this.getReservationByCartItemId(cartItem.id);
            reservation_list.push(reservation);
        }
        return(reservation_list);
    }

    /**
     * Cancel a reservation, without deleting it.
     * @param {Reservation} reservation
     */
    async cancelReservation(reservation) {
        const query = 'UPDATE RESERVATION SET canceledAt = ? WHERE cartItemId = ?';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [reservation.canceledAt, reservation.cartItem.id], async (err) => {
                if (err) {
                    console.err('Error updating canceledAt in Reservation: ', err.message);
                    reject(err);
                } else {
                    console.log('Reservation canceled succesfully');
                    await this.setAvailableAttributesForBags(reservation.cartItem.id, 1);
                    resolve(null);
                }
            })
        })
    }
}
