import dayjs from 'dayjs';
import {Bag} from '../models/index.mjs'
import {BagItem} from '../models/index.mjs';
import {BagItemRepo} from './index.mjs'

export class BagRepo {
    constructor(db) {
        this.DB = db;
    }

    /** 
     * Creates a new empty bag.
     * @param {Bag} bag
     * @returns {Bag} - The bag that was added to the cart, with the new ID generated by the system.
     */
    async createBag2(bag) {
        let query = 'INSERT INTO BAG (estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available) VALUES (?, ?, ?, ?, ?, ?, ?, ?)';
        const db = this.DB;
        const self = this; // Preserve the 'this' context of the BagRepo in order to use getBagById(this.lastID) in the callback
        
        console.log("FUCKING BAG: ", bag);
        
        return new Promise((resolve, reject) => {
            this.DB.run(query, [bag.estId, bag.size, bag.bagType, bag.tags, bag.price, bag.pickupTimeStart, bag.pickupTimeEnd, bag.available], async function (err) {
                if (err) {
                    console.error('Error inserting bag: ', err.message);
                    reject(err);
                } else {
                    console.log('Bag inserted successfully with ID:', this.lastID);
                    

                    console.log("FUCKING BAG2: ", bag.items);
                    // creating all the bagItems records in the db
                    let bagItemRepo = new BagItemRepo(db);
                    bag.items.forEach(async bagItem => {
                        bagItem.bagId = this.lastID; // set the bagId of the bagItem to the id of the bag just created!!!
                        await bagItemRepo.createBagItem(bagItem);
                    })

                    // fetch all the data of the bag
                    let fetchedBag = await self.getBagById(this.lastID);
                    const bagItem_list = await self.getItems(fetchedBag);
                    fetchedBag.items = bagItem_list;

                    console.log("Bag created: ", fetchedBag);
                    resolve(fetchedBag);
                }
            })
        })
    }


    async createBag(bag) {
        const db = this.DB;
        const self = this; // Preserve the 'this' context of the BagRepo in order to use getBagById(this.lastID) in the callback
        let query = 'INSERT INTO Bag (estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available) VALUES (?, ?, ?, ?, ?, ?, ?, ?)';
        
        
        
        return new Promise((resolve, reject) => {
            this.DB.run(query, [bag.estId, bag.size, bag.bagType, bag.tags, bag.price, bag.pickupTimeStart, bag.pickupTimeEnd, bag.available], async function (err) {
                if (err) {
                    console.error('Error inserting bag: ', err.message);
                    reject(err);
                } else {
                    console.log('Bag inserted successfully with ID:', this.lastID);

                    // fetch all the data of the bag
                    let fetchedBag = await self.getBagById(this.lastID);

                    // creating all the bagItems records in the db
                    let bagItemRepo = new BagItemRepo(db);
                    // Iterate over the bag.items which 
                    if (bag.items && Array.isArray(bag.items)) {
                        for (const bagItem of bag.items) { 
                            bagItem.bagId = this.lastID; // set the bagId of the bagItem to the id of the bag just created!!!
                            const res = await bagItemRepo.createBagItem(bagItem);
                        }

                        const bagItem_list = await self.getItems(this.lastID);
                        fetchedBag.items = bagItem_list;

                        resolve(fetchedBag);
                    } else {
                        resolve(fetchedBag); // If there are no items, just resolve with the fetched bag
                    }
                }
            });
        });
    }

    /**
     * 
     * @param {Bag} bag 
     * @returns 
     */
    async updateBag(bag) {
        let query = 'UPDATE BAG SET estId = ?, size = ?, bagType = ?, tags = ?, price = ?, pickupTimeStart = ?, pickupTimeEnd = ?, available = ? WHERE id = ?'
        return new Promise((resolve, reject) => {
            this.DB.run(query, [bag.estId, bag.size, bag.bagType, bag.tags, bag.price, bag.pickupTimeStart, bag.pickupTimeEnd, bag.available, bag.id], (err) => {
                if (err) {
                    console.error('Error inserting bag: ', err.message);
                    reject(err);
                } else {
                    console.log('Bag inserted successfully');
                    resolve(null);
                }
            })
        })
    }
    
    /**
     * Returns the bag with the given ID.
     * @param {number} id
     * @returns {Bag}
     */
    async getBagById(id) {
        let query = 'SELECT * FROM BAG WHERE id = ?'
        return new Promise((resolve, reject) => {
            this.DB.all(query, [id], async (err, row) => {
                if (err) {
                    console.error('Error inserting bag: ', err.message);
                    reject(err);
                } else {
                    if (row && row.length > 0) {
                        const id = parseInt(row[0].id, 10);
                        const estId = parseInt(row[0].estId, 10);
                        const size = row[0].size;
                        const bagType = row[0].bagType;
                        const tags = row[0].tags;
                        const price = parseFloat(row[0].price);
                        const pickupTimeStart = dayjs(row[0].pickupTimeStart, 'YYYY-MM-DD');
                        const pickupTimeEnd = dayjs(row[0].pickupTimeEnd, 'YYYY-MM-DD');
                        const available = Boolean(row[0].available);
                        
                        //constructor(id, bagType, estId, size, tags, price, items, pickupTimeStart, pickupTimeEnd, available)
                        const fetchedBag = new Bag(id,  bagType, estId, size, tags, price, null, pickupTimeStart, pickupTimeEnd, available);
                        const bagItem_list = await this.getItems(id); //pass the id of the bag to get the items
                        fetchedBag.items = bagItem_list;
                        resolve(fetchedBag);
                    } else {
                        resolve(null);
                    }
                }
            })
        })
    }


    /**
     * @param {Bag} bag
     * @returns {Array<BagItem>}
     */

    async getItems(id) {
        let bagItemRepo = new BagItemRepo(this.DB);
        const bagItem_list = await bagItemRepo.getBagItemListByBagId(id);
        console.log("BAGITEM_LIST ALLA FINE: ", bagItem_list);
        return bagItem_list;
    }



    async getBagListByEstId(estId) {
        let query = 'SELECT * FROM BAG WHERE estId = ?';
        return new Promise((resolve, reject) => { 
            this.DB.all(query, [estId], async (err, rows) => {
                if (err) {
                    console.error('Error retrieving bag list ', err.message);
                    reject(err);
                } else {
                    if (rows) {
                        const bag_list = [];
                        console.log("BAGLIST rows: ", rows);
    
                        for (const row of rows) {
                            let id = parseInt(row.id, 10);
                            let estId = parseInt(row.estId, 10);
                            let size = row.size;
                            let bagType = row.bagType;
                            let tags = row.tags;
                            let price = parseFloat(row.price);
                            let pickupTimeStart = dayjs(row.pickupTimeStart, 'YYYY-MM-DD');
                            let pickupTimeEnd = dayjs(row.pickupTimeEnd, 'YYYY-MM-DD');
                            let available = Boolean(row.available);
    
                            const fetchedBag = new Bag(id, estId, size, bagType, tags, price, null, pickupTimeStart, pickupTimeEnd, available);
                            const bagItem_list = await this.getItems(fetchedBag);
                            fetchedBag.items = bagItem_list;
                            bag_list.push(fetchedBag);
                        }
                        resolve(bag_list);
                    } else {
                        console.log('No bags found for the given establishment ID');
                        resolve(null);
                    }
                }
            });
        });
    }


    //get all bags from the db
    /**
     * @param {number} estId
     * @returns {Array<Bag>} - The list of bags that were added to the cart, with the new ID generated by the system.
     */
    async getAllBags() {
        let query = 'SELECT * FROM BAG';
        return new Promise((resolve, reject) => {
            this.DB.all(query, [], async (err, rows) => {
                if (err) {
                    console.error('Error retrieving bag list ', err.message);
                    reject(err);
                } else {
                    if (rows) {
                        const bag_list = [];

                        for (const row of rows) {
                            let id = parseInt(row.id, 10);
                            let estId = parseInt(row.estId, 10);
                            let size = row.size;
                            let bagType = row.bagType;
                            let tags = row.tags;
                            let price = parseFloat(row.price);
                            let pickupTimeStart = dayjs(row.pickupTimeStart, 'YYYY-MM-DD');
                            let pickupTimeEnd = dayjs(row.pickupTimeEnd, 'YYYY-MM-DD');
                            let available = Boolean(row.available);

                            const fetchedBag = new Bag(id, estId, size, bagType, tags, price, null, pickupTimeStart, pickupTimeEnd, available);
                            const bagItem_list = await this.getItems(fetchedBag);
                            fetchedBag.items = bagItem_list;
                            
                            bag_list.push(fetchedBag);
                        }
                        resolve(bag_list);
                    } else {
                        console.log('No bags found for the given establishment ID');
                        resolve(null);
                    }
                }
            });
        });
    }

    /**
     * @param {number} id
     */
    
    async setAvailable(id, available) {
        let query = 'UPDATE BAG SET available = ? WHERE id = ?';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [available, id], (err) => {
                if (err) {
                    console.error('Error setting available for the bag: ', err.message);
                    reject(err);
                } else {
                    console.log('available for the bag succesfully set');
                    resolve(null);
                }
            })
        })
    }

    /**
     * Lists all the available bags, from every establishment.
     * A bag is available if no one reserved it yet and it can be picked up now.
     * 
     * @returns {Array<Bag>}
     */
    async listAvailable() {
        let query = "SELECT * FROM BAG WHERE available = 1 AND DATE('now') < DATE(pickupTimeEnd)";
        return new Promise((resolve, reject) => {
            this.DB.all(query, [], async (err, rows) => {
                if (err) {
                    console.error('error retriving all available bags', err.message);
                    reject(err);
                } else {
                    let bag_list = [];

                    if (rows && rows.length > 0) {
                        console.log("ROWS: ", rows);
                        for (const row of rows) {
                            let id = parseInt(row.id, 10);
                            let estId = parseInt(row.estId, 10);
                            let size = row.size;
                            let bagType = row.bagType;
                            let tags = row.tags;
                            let price = parseFloat(row.price);
                            let pickupTimeStart = dayjs(row.pickupTimeStart, 'YYYY-MM-DD');
                            let pickupTimeEnd = dayjs(row.pickupTimeEnd, 'YYYY-MM-DD');
                            let available = Boolean(row.available);
    
                            const currentDate = dayjs();
                            if (currentDate.isBefore(pickupTimeEnd)) {
                            
                                let fetchedBag = new Bag(id, estId, size, bagType, tags, price, null, pickupTimeStart, pickupTimeEnd, available);
                                const bagItem_list = await this.getItems(fetchedBag);
                                fetchedBag.items = bagItem_list;

                                bag_list.push(fetchedBag);
                            }
                        }
                        resolve(bag_list);
                    } else {
                        resolve(null);
                    }
                }                   
            })
        })
    }


    async checkBagAvailable(bagId){
        const query = 'SELECT available FROM BAG WHERE id = ?';
        return new Promise((resolve, reject) => {
            this.DB.get(query, [bagId], (err, row) => {
                if (err) {
                    console.error('Error checking bag availability: ', err.message);
                    reject(err);
                } else {
                    //this returns eithr true or false if the row is defined
                    //otherwise it returns null
                    if (row){
                        resolve(row.available === 1); // Convert to boolean
                    } else {
                        resolve(null); // No such bag found
                    }
                }
            });
        });
    }
    

    /**
     * Creates and adds a new item to the bag.
     * @param {BagItem} bagItem
     * @returns {BagItem} - The item that was added to the bag, with the ID generated by the system.
     */
    async addItem(bagItem) {
        let bagItemRepo = new BagItemRepo(this.DB);
        const bagItemReturned = await bagItemRepo.createBagItem(bagItem.bagId, bagItem.name, bagItem.quantity, bagItem.measurementUnit);

        return bagItemReturned;
    }

    /**
     * Remove and deletes the item in the bag.
     * @param {BagItemId} bagItemId
     */
    async removeItem(bagItemId) {
        let bagItemRepo = new BagItemRepo(this.DB);
        const res = await bagItemRepo.deleteBagItem(bagItemId);

        return res;
    }

}