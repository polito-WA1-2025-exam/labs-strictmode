import sqlite3 from 'sqlite3';
import {pathDbFromRepos, connect} from '../../database/index.js';
import { Bag } from '../models/index.mjs'

export class BagRepo {

    constructor() {
        this.pathDB = pathDbFromRepos;
        this.DB = connect(this.pathDB);
    }

    /** 
     * Creates a new empty bag.
     * @param {number} estId - The establishment ID associated with the bag.
     * @param {number} size - "small", "medium", "large".
     * @param {Bag} bagType - Type of the bag (e.g., "regular", "surprise").
     * @param {Array<string>} tags - Example: ["vegan", "gluten free"].
     * @param {number} price - The price of the bag.
     * @param {string} pickupTimeStart - The start time for pickup in ISO 8601 format.
     * @param {string} pickupTimeEnd - The end time for pickup in ISO 8601 format.
     * @param {boolean} available - 1 if the bag has not been bought yet. 0 otherwise
     * @returns {Bag} - The bag that was added to the cart, with the new ID generated by the system.
     */
    async createBag(estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available) {
        let query = 'INSERT INTO BAG (estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available) VALUES (?, ?, ?, ?, ?, ?, ?, ?)';
        return new Promise((resolve, reject) => {
            this.DB.run(query, [estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available], (err) => {
                if (err) {
                    console.error('Error inserting bag: ', err.message);
                    reject(err);
                } else {
                    console.log('Bag inserted successfully');
                    resolve(null);
                }
            })
        })
    }

    async updateBag(id, estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available) {
        let query = 'UPDATE BAG SET estId = ?, size = ?, bagType = ?, tags = ?, price = ?, pickupTimeStart = ?, pickupTimeEnd = ?, available = ? WHERE id = ?'
        return new Promise((resolve, reject) => {
            this.DB.run(query, [estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available, id], (err) => {
                if (err) {
                    console.error('Error inserting bag: ', err.message);
                    reject(err);
                } else {
                    console.log('Bag inserted successfully');
                    resolve(null);
                }
            })
        })
    }
    
    /**
     * Returns the bag with the given ID.
     * @param {number} bagId
     * @returns {Bag}
     */
    async getBag(id) {
        let query = 'SELECT * FROM BAG WHERE id = ?'
        return new Promise((resolve, reject) => {
            this.DB.all(query, [resolve, reject], (err, row) => {
                if (err) {
                    console.error('Error inserting bag: ', err.message);
                    reject(err);
                } else {
                    if (row) {
                        let id = row[0].id;
                        let estId = parseInt(row[0].estId, 10);
                        let size = row[0].size;
                        let bagType = row[0].bagType;
                        let tags = row[0].tags;
                        let price = row[0].price;
                        pickupTimeStart = row[0].pickupTimeStart;
                        pickupTimeEnd = row[0].pickupTimeEnd;
                        let available = row[0].available;

                        let bag = new Bag(id, estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available);
                        resolve(bag);
                    } else {
                        resolve(null);
                    }
                }
            })
        })
    }

    

    /**
     * Lists all the available bags, from every establishment.
     * A bag is available if no one reserved it yet and it can be picked up now.
     * 
     * @returns {Array<Bag>}
     */
    async listAvailable() {
        let query = 'SELECT * FROM BAG WHERE available = 1'
        return new Promise((resolve, reject) => {
            this.DB.all(query, [resolve, reject], (err, rows) => {
                if (err) {
                    console.error('error retriving all available bags', err.message);
                    reject(err);
                } else {
                    let bag_list = [];

                    if (rows) {
                        rows.forEach(row => {
                            let id = row.id;
                            let estId = parseInt(row.estId, 10);
                            let size = row.size;
                            let bagType = row.bagType;
                            let tags = row.tags;
                            let price = parseFloat(row.price);
                            let pickupTimeStart = row.pickupTimeStart;
                            let pickupTimeEnd = row.pickupTimeEnd;
                            let available = row.available;
    
                            let bag = new Bag(id, estId, size, bagType, tags, price, pickupTimeStart, pickupTimeEnd, available);
    
                            bag_list.push(bag);
                        })
                        resolve(bag_list);
                    } else {
                        resolve(null);
                    }
                }                   
            })
        })
    }
    

    /**
     * Creates and adds a new item to the bag.
     * @param {number} bagId
     * @param {string} name
     * @param {number} quantity - Must always be greater than 0.
     * @returns {BagItem} - The item that was added to the bag, with the ID generated by the system.
     */
    async addItem(bagId, name, quantity) { }

    /**
     * Remove and deletes the item in the bag.
     * @param {number} bagId
     * @param {number} itemId
     */
    async removeItem(bagId, itemId) { }

}